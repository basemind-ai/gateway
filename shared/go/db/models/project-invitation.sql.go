// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: project-invitation.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteProjectInvitation = `-- name: DeleteProjectInvitation :exec
DELETE FROM project_invitation
WHERE id = $1
`

func (q *Queries) DeleteProjectInvitation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProjectInvitation, id)
	return err
}

const retrieveProjectInvitationByID = `-- name: RetrieveProjectInvitationByID :one
SELECT
    up.id,
    up.email,
    up.permission,
    up.project_id
FROM project_invitation AS up
LEFT JOIN project AS p ON up.project_id = p.id
WHERE up.id = $1 AND p.deleted_at IS NULL
`

type RetrieveProjectInvitationByIDRow struct {
	ID         pgtype.UUID          `json:"id"`
	Email      string               `json:"email"`
	Permission AccessPermissionType `json:"permission"`
	ProjectID  pgtype.UUID          `json:"projectId"`
}

func (q *Queries) RetrieveProjectInvitationByID(ctx context.Context, id pgtype.UUID) (RetrieveProjectInvitationByIDRow, error) {
	row := q.db.QueryRow(ctx, retrieveProjectInvitationByID, id)
	var i RetrieveProjectInvitationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Permission,
		&i.ProjectID,
	)
	return i, err
}

const retrieveProjectInvitations = `-- name: RetrieveProjectInvitations :many
SELECT
    up.id,
    up.email,
    up.permission,
    up.created_at,
    up.updated_at
FROM project_invitation AS up
LEFT JOIN project AS p ON up.project_id = p.id
WHERE
    up.project_id = $1 AND p.deleted_at IS NULL
ORDER BY up.created_at
`

type RetrieveProjectInvitationsRow struct {
	ID         pgtype.UUID          `json:"id"`
	Email      string               `json:"email"`
	Permission AccessPermissionType `json:"permission"`
	CreatedAt  pgtype.Timestamptz   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamptz   `json:"updatedAt"`
}

func (q *Queries) RetrieveProjectInvitations(ctx context.Context, projectID pgtype.UUID) ([]RetrieveProjectInvitationsRow, error) {
	rows, err := q.db.Query(ctx, retrieveProjectInvitations, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RetrieveProjectInvitationsRow
	for rows.Next() {
		var i RetrieveProjectInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Permission,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertProjectInvitation = `-- name: UpsertProjectInvitation :one
INSERT INTO project_invitation (
    email, project_id, permission
) VALUES (
    $1, $2, $3
)
ON CONFLICT (email, project_id) DO UPDATE
SET permission = $3
RETURNING id, email, project_id, permission, created_at, updated_at
`

type UpsertProjectInvitationParams struct {
	Email      string               `json:"email"`
	ProjectID  pgtype.UUID          `json:"projectId"`
	Permission AccessPermissionType `json:"permission"`
}

func (q *Queries) UpsertProjectInvitation(ctx context.Context, arg UpsertProjectInvitationParams) (ProjectInvitation, error) {
	row := q.db.QueryRow(ctx, upsertProjectInvitation, arg.Email, arg.ProjectID, arg.Permission)
	var i ProjectInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.ProjectID,
		&i.Permission,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
